
/**
	* rnd64_st.c
	*
	* Version:       0.30 st
	* Version note:  Experimental, Linux-only, single-threaded version using write() to bypass OS buffers. 2.1GB max data dump.
	* License:       GNU GPL version 3.0 (GPL v3); http://www.gnu.org/licenses/gpl.html
	* Purpose:       Large file dump.
	* Author:        Martin Latter, November 2015. Revised March 2017.
	* URL:           https://github.com/Tinram/RND64
	*
	* Compile (GCC x64):
	*                    Linux:      gcc rnd64_st.c -o rnd64_st -O3 -Wall -Wextra -Wuninitialized -Wunused -Werror -std=gnu99 -s
	*
	*                    further CPU optimisation examples:
	*                                -march=core-avx-i -mtune=core-avx-i        Intel Ivy Bridge
	*                                -march=core-avx2 -mtune=core-avx2          Intel Haswell
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <inttypes.h>
#include <unistd.h>
#include <fcntl.h>

#define RND64_VERSION "0.30 st"
#define RANDOM_PATH "/dev/urandom"


void menu(char* pFilename);


const float cMBRecip = 0.000976562;
char* pFilename;


int main(int iArgCount, char* aArgV[]) {

	/* arguments check */
	if (iArgCount < 3) {

		menu(aArgV[0]);
		return EXIT_FAILURE;
	}

	/* initial variables */
	int iAll = strcmp(aArgV[1], "-a");
	int iSingleChar = strcmp(aArgV[1], "-f");
	int iRestricted = strcmp(aArgV[1], "-r");
	int iCrypto = strcmp(aArgV[1], "-c");

	pFilename = aArgV[0];

	if (iAll != 0 && iSingleChar != 0 && iRestricted != 0 && iCrypto != 0) {

		menu(pFilename);
		return EXIT_FAILURE;
	}

	/* main variables */
	int iSizeLen = strlen(aArgV[2]);
	int iMSec;
	int iFileDesc;
	char cUnit;
	char sFileSize[iSizeLen];
	char* pBuffer;
	uint64_t i, iBytes;
	size_t iResult = 0;
	clock_t tStart, tDiff;
	FILE* pUrand;

	/* get size character */
	cUnit = aArgV[2][iSizeLen - 1];
	cUnit = tolower(cUnit);

	/* check size character */
	if (cUnit != 'k' && cUnit != 'm' && cUnit != 'g') {

		fprintf(stderr, "\n%s: please specify the file/stream size with a suffix of k, m, or g\n\n", pFilename);
		return EXIT_FAILURE;
	}

	/* substring filesize */
	strncpy(sFileSize, aArgV[2], iSizeLen - 1);
	sFileSize[iSizeLen - 1] = '\0';

	/* convert filesize to unsigned 64-bit */
	iBytes = strtoull(sFileSize, (char**) NULL, 10);

	/* convert unit to bytes */
	if (cUnit == 'k') {
		iBytes = 1024 * iBytes;
	}
	else if (cUnit == 'm') {
		iBytes = 1024 * 1024 * iBytes;
	}
	else if (cUnit == 'g') {
		iBytes = 1024 * 1024 * 1024 * iBytes;
	}
	else {

		fprintf(stderr, "\n%s: file size error!\n\n", pFilename);
		return EXIT_FAILURE;
	}

	/* create seed for rand() usage */
	srand((unsigned int) time(NULL));

	/* timer start */
	tStart = clock();

	pBuffer = (char*) malloc(iBytes + 1); /* +1 for 0 */

	if (pBuffer == NULL) {
		fprintf(stderr, "\n%s: insufficient memory to allocate %"PRId64" bytes.\n\n", pFilename, iBytes);
		return EXIT_FAILURE;
	}

	/* populate buffer with all ASCII characters */
	if (iAll == 0) {

		for (i = 0; i < iBytes; i++) {
			pBuffer[i] = (rand() % 254) + 1; /* avoid 0 */
		}
	}
	else if (iSingleChar == 0) { /* with single character (0) */

		memset(pBuffer, 48, iBytes);
	}
	else if (iRestricted == 0) { /* with ASCII characters 33 to 127 */

		for (i = 0; i < iBytes; i++) {
			pBuffer[i] = (rand() % 94) + 33;
		}
	}
	else { /* with crypto-generated bytes */

		if ((pUrand = fopen(RANDOM_PATH, "r")) == NULL) {

			fprintf(stderr, "\n%s: secure data generation unavailable.\n\n", pFilename);
			free(pBuffer); /* deallocate */
			return EXIT_FAILURE;
		}

		if (fread(pBuffer, 1, iBytes, pUrand) != iBytes) {

			fprintf(stderr, "\n%s: insufficient crypto random bytes available.\n\n", pFilename);
			fclose(pUrand);
			free(pBuffer); /* deallocate */
			return EXIT_FAILURE;
		}
		else { /* buffer populated, close stream */
			fclose(pUrand);
		}
	}

	pBuffer[iBytes] = '\0';

	/* create stream if no specified <file> argument, then exit */
	if (aArgV[3] == NULL) {

		iResult = write(1, pBuffer, iBytes);

			if (iResult < 1) {

				free(pBuffer); /* deallocate */
				fprintf(stderr, "\n%s: output failure.\n\n", pFilename);
				return EXIT_FAILURE;
			}

		free(pBuffer); /* deallocate */
		return EXIT_SUCCESS;
	}

	/* else write buffer to file */

	/* create file descriptor */
	iFileDesc = open(aArgV[3], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);

	if (iFileDesc < 0) {

		free(pBuffer); /* deallocate */
		fprintf(stderr, "\n%s: output file cannot be written.\n(check write permissions / filename characters)\n\n", pFilename);
		return EXIT_FAILURE;
	}
	else {

		/* straight write avoiding caching, no chunking, no apparent difference */
		iResult = write(iFileDesc, pBuffer, iBytes);

		if (iResult < 1) {

			close(iFileDesc);
			free(pBuffer); /* deallocate */
			fprintf(stderr, "\n%s: output file cannot be written.\n(check write permissions / filename characters)\n\n", pFilename);
			return EXIT_FAILURE;
		}
	}

	/* timer end */
	tDiff = clock() - tStart;

	printf("\n%s generated\n\nsize: %"PRId64" bytes\n", aArgV[3], iBytes);

	/* timer display, by Ben Alpert */
	iMSec = tDiff * 1000 / CLOCKS_PER_SEC;
	printf("time: %d s %d ms\n", iMSec / 1000, iMSec % 1000);

	/* MB/s calculation for filesize over 50MB */
	if (iBytes > 52428800) {
		printf("MB/s: %0.2f\n", (float) ((iBytes * cMBRecip * cMBRecip) / (iMSec * 0.001)));
	}

	printf("\n");

	/* close file descriptor */
	// close(iFileDesc); /* !experimental - there can be a large speed decrease when enabled */

	/* deallocate */
	free(pBuffer);

	return EXIT_SUCCESS;
}


/**
	* Display menu.
	*
	* @param   char* pFilename, name from aArgV[0]
	* @return  void
*/

void menu(char* pFilename) {

	printf("\nRND64 v.%s\n", RND64_VERSION);
	printf("\nUsage:\n");
	printf("\t\t%s [option] <size> [file]", pFilename);
	printf("\n\t\t%s [option] <size> | <prog>", pFilename);
	printf("\n\nOptions:");
	printf("\n\t\t-a\t chars 1-255    (all)");
	printf("\n\t\t-f\t single char    (fastest)");
	printf("\n\t\t-r\t chars 33-126   (restrict)");
	printf("\n\t\t-c\t crypto bytes");
	printf("\n\n\t\tsize\t 1K, 100M, 3G\n\n");
}
